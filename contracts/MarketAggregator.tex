
\chapter{Contract MarketAggregator}

\minitoc

\section{Overview}


In file {\tt MarketsAggregator.sol}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
IRoles & \\\hline
IUpgradableContract & \\\hline
IMarketOracle & \\\hline
IMarketSetters & \\\hline
IMarketOwnerFunctions & \\\hline
IMarketGetters & \\\hline
IMarketOperations & \\\hline
IContractStateCacheRoot & \\\hline
\end{tabular}


\section{Event Definitions}


\begin{lstlisting}[firstnumber=32]
    event MarketCreated(uint32 marketId, MarketInfo marketState);
\end{lstlisting}

\begin{lstlisting}[firstnumber=33]
    event MarketDeleted(uint32 marketId, MarketInfo marketState);
\end{lstlisting}

\begin{lstlisting}[firstnumber=34]
    event LiquidationPossible(address tonWallet, fraction accountHealth);
\end{lstlisting}

\section{Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
uint32 & contractCodeVersion &  \\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
address & userAccountManager &  \\\hline
 & & used in @2.MarketAggregator.upgradeContractCode\\\hline
 & & assigned in @2.MarketAggregator.setUserAccountManager\\\hline
 & & used in @2.MarketAggregator.setUserAccountManager\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.getServiceContractAddresses\\\hline
 & & used in @2.MarketAggregator.calculateUserAccountHealth\\\hline
address & walletController &  \\\hline
 & & used in @2.MarketAggregator.upgradeContractCode\\\hline
 & & assigned in @2.MarketAggregator.setWalletController\\\hline
 & & used in @2.MarketAggregator.setWalletController\\\hline
 & & used in @2.MarketAggregator.requestTokenPayout\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.getServiceContractAddresses\\\hline
address & oracle &  \\\hline
 & & used in @2.MarketAggregator.upgradeContractCode\\\hline
 & & used in @2.MarketAggregator.updatePrice\\\hline
 & & assigned in @2.MarketAggregator.setOracleAddress\\\hline
 & & used in @2.MarketAggregator.setOracleAddress\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.getServiceContractAddresses\\\hline
 & & used in @2.MarketAggregator.\_{}updateAllPrices\\\hline
mapping (uint32 =$>$ bool) & createdMarkets &  \\\hline
 & & assigned in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.removeMarket\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.createNewMarket\\\hline
 & & used in @2.MarketAggregator.createNewMarket\\\hline
 & & used in @2.MarketAggregator.createNewMarket\\\hline
mapping (address =$>$ uint32) & tokensToMarkets &  \\\hline
 & & assigned in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.performOperationWalletController\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.createNewMarket\\\hline
 & & used in @2.MarketAggregator.createNewMarket\\\hline
mapping (uint32 =$>$ MarketInfo) & markets &  \\\hline
 & & used in @2.MarketAggregator.upgradeContractCode\\\hline
 & & used in @2.MarketAggregator.updateModulesCache\\\hline
 & & assigned in @2.MarketAggregator.updateMarketParameters\\\hline
 & & used in @2.MarketAggregator.updateMarketParameters\\\hline
 & & used in @2.MarketAggregator.updateMarketParameters\\\hline
 & & used in @2.MarketAggregator.requestTokenPayout\\\hline
 & & assigned in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.removeMarket\\\hline
 & & used in @2.MarketAggregator.receiveCacheDelta\\\hline
 & & used in @2.MarketAggregator.performOperation\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.getMarketInformation\\\hline
 & & used in @2.MarketAggregator.getAllMarkets\\\hline
 & & used in @2.MarketAggregator.createNewMarket\\\hline
 & & assigned in @2.MarketAggregator.createNewMarket\\\hline
 & & used in @2.MarketAggregator.createNewMarket\\\hline
 & & used in @2.MarketAggregator.calculateUserAccountHealth\\\hline
 & & used in @2.MarketAggregator.addModule\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & used in @2.MarketAggregator.\_{}updateMarketDelta\\\hline
 & & assigned in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateExchangeRate\\\hline
 & & used in @2.MarketAggregator.\_{}updateAllMarkets\\\hline
 & & used in @2.MarketAggregator.\_{}createUpdatedIndexes\\\hline
 & & assigned in @2.MarketAggregator.\_{}acquireInterest\\\hline
 & & used in @2.MarketAggregator.\_{}acquireInterest\\\hline
 & & assigned in @2.MarketAggregator.\_{}acquireInterest\\\hline
 & & used in @2.MarketAggregator.\_{}acquireInterest\\\hline
 & & used in @2.MarketAggregator.\_{}acquireInterest\\\hline
 & & used in @2.MarketAggregator.\_{}acquireInterest\\\hline
 & & used in @2.MarketAggregator.\_{}acquireInterest\\\hline
mapping (address =$>$ fraction) & tokenPrices &  \\\hline
 & & used in @2.MarketAggregator.upgradeContractCode\\\hline
 & & used in @2.MarketAggregator.updateModulesCache\\\hline
 & & assigned in @2.MarketAggregator.receiveUpdatedPrice\\\hline
 & & used in @2.MarketAggregator.receiveUpdatedPrice\\\hline
 & & used in @2.MarketAggregator.receiveCacheDelta\\\hline
 & & assigned in @2.MarketAggregator.receiveAllUpdatedPrices\\\hline
 & & used in @2.MarketAggregator.receiveAllUpdatedPrices\\\hline
 & & used in @2.MarketAggregator.receiveAllUpdatedPrices\\\hline
 & & assigned in @2.MarketAggregator.receiveAllUpdatedPrices\\\hline
 & & used in @2.MarketAggregator.receiveAllUpdatedPrices\\\hline
 & & used in @2.MarketAggregator.performOperation\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.getTokenPrices\\\hline
 & & used in @2.MarketAggregator.calculateUserAccountHealth\\\hline
 & & used in @2.MarketAggregator.addModule\\\hline
mapping (address =$>$ bool) & realTokenRoots &  \\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
mapping (uint8 =$>$ address) & modules &  \\\hline
 & & used in @2.MarketAggregator.upgradeContractCode\\\hline
 & & used in @2.MarketAggregator.updateModulesCache\\\hline
 & & assigned in @2.MarketAggregator.removeModule\\\hline
 & & used in @2.MarketAggregator.removeModule\\\hline
 & & used in @2.MarketAggregator.removeModule\\\hline
 & & used in @2.MarketAggregator.performOperation\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.getAllModules\\\hline
 & & assigned in @2.MarketAggregator.addModule\\\hline
 & & used in @2.MarketAggregator.addModule\\\hline
uint128 & moduleAmount &  \\\hline
 & & used in @2.MarketAggregator.updateModulesCache\\\hline
 & & assigned in @2.MarketAggregator.removeModule\\\hline
 & & used in @2.MarketAggregator.removeModule\\\hline
 & & used in @2.MarketAggregator.removeModule\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.addModule\\\hline
 & & used in @2.MarketAggregator.addModule\\\hline
 & & used in @2.MarketAggregator.addModule\\\hline
mapping (address =$>$ bool) & isModule &  \\\hline
 & & assigned in @2.MarketAggregator.removeModule\\\hline
 & & used in @2.MarketAggregator.removeModule\\\hline
 & & assigned in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & used in @2.MarketAggregator.onCodeUpgrade\\\hline
 & & assigned in @2.MarketAggregator.addModule\\\hline
 & & used in @2.MarketAggregator.addModule\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=14]
    uint32 public contractCodeVersion;
\end{lstlisting}

\begin{lstlisting}[firstnumber=16]
    address public userAccountManager;
\end{lstlisting}

\begin{lstlisting}[firstnumber=17]
    address public walletController;
\end{lstlisting}

\begin{lstlisting}[firstnumber=18]
    address public oracle;
\end{lstlisting}

\begin{lstlisting}[firstnumber=19]
    mapping(uint32 => bool) createdMarkets;
\end{lstlisting}

\begin{lstlisting}[firstnumber=20]
    mapping(address => uint32) tokensToMarkets;
\end{lstlisting}

\begin{lstlisting}[firstnumber=21]
    mapping(uint32 => MarketInfo) markets;
\end{lstlisting}

\begin{lstlisting}[firstnumber=22]
    mapping(address => fraction) tokenPrices;
\end{lstlisting}

\begin{lstlisting}[firstnumber=23]
    mapping(address => bool) realTokenRoots;
\end{lstlisting}

\begin{lstlisting}[firstnumber=25]
    mapping(uint8 => address) public modules;
\end{lstlisting}

\begin{lstlisting}[firstnumber=26]
    uint128 moduleAmount;
\end{lstlisting}

\begin{lstlisting}[firstnumber=27]
    mapping(address => bool) isModule;
\end{lstlisting}

\section{Modifier Definitions}


\subsection{Modifier onlySelf}


\begin{lstlisting}[firstnumber=510]
    modifier onlySelf() {
        require(msg.sender == address(this), MarketErrorCodes.ERROR_MSG_SENDER_IS_NOT_SELF);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyOracle}


\begin{lstlisting}[firstnumber=515]
    modifier onlyOracle() {
        require(msg.sender == oracle, MarketErrorCodes.ERROR_MSG_SENDER_IS_NOT_ORACLE);
        tvm.rawReserve(msg.value, 2);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyUserAccountManager}


\begin{lstlisting}[firstnumber=521]
    modifier onlyUserAccountManager() {
        require(msg.sender == userAccountManager, MarketErrorCodes.ERROR_MSG_SENDER_IS_NOT_USER_ACCOUNT_MANAGER);
        tvm.rawReserve(msg.value, 2);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyWalletController}


\begin{lstlisting}[firstnumber=527]
    modifier onlyWalletController() {
        require(msg.sender == walletController, MarketErrorCodes.ERROR_MSG_SENDER_IS_NOT_TIP3_WALLET_CONTROLLER);
        tvm.rawReserve(msg.value, 2);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyRealTokenRoot}


\begin{lstlisting}[firstnumber=533]
    modifier onlyRealTokenRoot() {
        require(realTokenRoots.exists(msg.sender));
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyModule}


\begin{lstlisting}[firstnumber=538]
    modifier onlyModule() {
        require(isModule.exists(msg.sender));
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyExecutor}


\begin{lstlisting}[firstnumber=543]
    modifier onlyExecutor() {
        require(
            (msg.sender == userAccountManager) ||
            (isModule.exists(msg.sender))
        );
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\issueCritical{Constructor for MarketAggregator (fake)}{loren ipsum  loren ipsum  loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum

loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum
loren ipsum loren ipsum loren ipsum }
\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=39]
    constructor(address _newOwner) public {
        tvm.accept();
        _owner = _newOwner;
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function addModule}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=332]
    function addModule(uint8 operationId, address module) external canChangeParams {
        tvm.rawReserve(msg.value, 2);
        modules[operationId] = module;
        isModule[module] = true;
        moduleAmount = moduleAmount + 1;
        IContractStateCache(module).updateCache{
            flag: MsgFlag.REMAINING_GAS
        }(_owner, markets, tokenPrices);
    }
\end{lstlisting}

\subsection{Function calculateUserAccountHealth}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=376]
    function calculateUserAccountHealth(
        address tonWallet, 
        address gasTo, 
        mapping(uint32 => uint256) supplyInfo, 
        mapping(uint32 => BorrowInfo) borrowInfo, 
        TvmCell dataToTransfer
    ) external override onlyUserAccountManager {
        tvm.rawReserve(msg.value, 2);

        _updateAllMarkets();

        mapping(uint32 => fraction) updatedIndexes = _createUpdatedIndexes();
        fraction accountHealth = Utilities.calculateSupplyBorrow(supplyInfo, borrowInfo, markets, tokenPrices);

        if (accountHealth.nom < accountHealth.denom) {
            emit LiquidationPossible(tonWallet, accountHealth);
        }

        IUAMUserAccount(userAccountManager).updateUserAccountHealth{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, gasTo, accountHealth, updatedIndexes, dataToTransfer);
    }
\end{lstlisting}

\subsection{Function createNewMarket}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=242]
    function createNewMarket(
        uint32 marketId, 
        address realToken,
        fraction _baseRate,
        fraction _utilizationMultiplier,
        fraction _reserveFactor,
        fraction _exchangeRate,
        fraction _collateralFactor,
        fraction _liquidationMultiplier
    ) external canChangeParams {
        tvm.rawReserve(msg.value, 2);
        if (!createdMarkets[marketId]) {
            createdMarkets[marketId] = true;
            
            fraction one = fraction({nom: 1, denom: 1});

            markets[marketId] = MarketInfo({
                token: realToken,
                realTokenBalance: 0,
                vTokenBalance: 0,
                totalBorrowed: 0,
                totalReserve: 0,

                index: one,
                baseRate: _baseRate,
                utilizationMultiplier: _utilizationMultiplier,
                reserveFactor: _reserveFactor,
                exchangeRate: _exchangeRate,
                collateralFactor: _collateralFactor,
                liquidationMultiplier: _liquidationMultiplier,

                lastUpdateTime: now
            });

            tokensToMarkets[realToken] = marketId;

            emit MarketCreated(marketId, markets[marketId]);
        } else {
            address(msg.sender).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
        }
    }
\end{lstlisting}

\subsection{Function forceUpdateAllPrices}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=471]
    function forceUpdateAllPrices() external override onlyOwner {
        tvm.rawReserve(msg.value, 2);
        TvmBuilder tb;
        tb.store(OperationCodes.NO_OP);
        _updateAllPrices(tb.toCell());
    }
\end{lstlisting}

\subsection{Function getAllMarkets}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=227]
    function getAllMarkets() external override view responsible returns(mapping(uint32 => MarketInfo)) {
        return {flag: MsgFlag.REMAINING_GAS} markets;
    }
\end{lstlisting}

\subsection{Function getAllModules}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=236]
    function getAllModules() external override view responsible returns(mapping(uint8 => address)) {
        return {flag: MsgFlag.REMAINING_GAS} modules;
    }
\end{lstlisting}

\subsection{Function getMarketInformation}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=223]
    function getMarketInformation(uint32 marketId) external override view responsible returns(MarketInfo) {
        return {flag: MsgFlag.REMAINING_GAS} markets[marketId];
    }
\end{lstlisting}

\subsection{Function getServiceContractAddresses}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=215]
    function getServiceContractAddresses() external override view responsible returns(address _userAccountManager, address _tip3WalletController, address _oracle) {
        return {flag: MsgFlag.REMAINING_GAS} (userAccountManager, walletController, oracle);
    }
\end{lstlisting}

\subsection{Function getTokenPrices}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=219]
    function getTokenPrices() external override view responsible returns(mapping(address => fraction)) {
        return {flag: MsgFlag.REMAINING_GAS} tokenPrices;
    }
\end{lstlisting}

\subsection{Function performOperationUserAccountManager}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=356]
    function performOperationUserAccountManager(uint8 operationId, uint32 marketId, TvmCell args) external override view onlyUserAccountManager {
        TvmCell payload = _createOperationUpdatePayload(operationId, marketId, args);
        _updateAllPrices(payload);
    }
\end{lstlisting}

\subsection{Function performOperationWalletController}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=350]
    function performOperationWalletController(uint8 operationId, address tokenRoot, TvmCell args) external override view onlyWalletController {
        uint32 marketId = tokensToMarkets[tokenRoot];
        TvmCell payload = _createOperationUpdatePayload(operationId, marketId, args);
        _updateAllPrices(payload);
    }
\end{lstlisting}

\subsection{Function receiveAllUpdatedPrices}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=457]
    function receiveAllUpdatedPrices(mapping(address => MarketPriceInfo) updatedPrices, TvmCell payload) external override onlyOracle {
        for((address t, MarketPriceInfo mpi): updatedPrices) {
            tokenPrices[t] = fraction(mpi.tokens, mpi.usd);
            tokenPrices[t] = tokenPrices[t].simplify();

            _updateAllMarkets();
        }

        performOperation(payload);
    }
\end{lstlisting}

\subsection{Function receiveCacheDelta}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=100]
    function receiveCacheDelta(mapping(uint32 => MarketDelta) marketsDelta, TvmCell args) external override onlyModule {
        tvm.rawReserve(msg.value, 2);
        for ((uint32 marketId, MarketDelta marketDelta): marketsDelta) {
            _acquireInterest(marketId);
            _updateMarketDelta(marketId, marketDelta);
            _updateExchangeRate(marketId);
        }

        IModule(msg.sender).resumeOperation{
            flag: MsgFlag.REMAINING_GAS
        }(args, markets, tokenPrices);
    }
\end{lstlisting}

\subsection{Function receiveUpdatedPrice}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=440]
    function receiveUpdatedPrice(address tokenRoot, uint128 nom, uint128 denom, TvmCell) external override onlyOracle {
        tokenPrices[tokenRoot] = fraction(nom, denom);
    }
\end{lstlisting}

\subsection{Function removeMarket}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=315]
    function removeMarket(
        uint32 marketId
    ) external canChangeParams {
        tvm.rawReserve(msg.value, 2);

        emit MarketDeleted(marketId, markets[marketId]);

        delete tokensToMarkets[markets[marketId].token];
        delete createdMarkets[marketId];
        delete markets[marketId];

        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function removeModule}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=342]
    function removeModule(uint8 operationId) external canChangeParams {
        tvm.rawReserve(msg.value, 2);
        delete isModule[modules[operationId]];
        delete modules[operationId];
        moduleAmount = moduleAmount - 1;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function requestTokenPayout}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=413]
    function requestTokenPayout(address tonWallet, address userTip3Wallet, uint32 marketId, uint256 toPayout) external override view onlyUserAccountManager {
        tvm.rawReserve(msg.value, 2);

        IWCMInteractions(walletController).transferTokensToWallet{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, markets[marketId].token, userTip3Wallet, toPayout);
    }
\end{lstlisting}

\subsection{Function setOracleAddress}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=501]
    function setOracleAddress(address _oracle) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        oracle = _oracle;
        address(msg.sender).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function setUserAccountManager}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=483]
    function setUserAccountManager(address _userAccountManager) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        userAccountManager = _userAccountManager;
        address(msg.sender).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function setWalletController}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=492]
    function setWalletController(address _tip3WalletController) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        walletController = _tip3WalletController;
        address(msg.sender).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function updateMarketParameters}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=284]
    function updateMarketParameters(
        uint32 marketId,
        fraction _baseRate,
        fraction _utilizationMultiplier,
        fraction _reserveFactor,
        fraction _exchangeRate,
        fraction _collateralFactor,
        fraction _liquidationMultiplier
    ) external canChangeParams {
        tvm.rawReserve(msg.value, 2);

        MarketInfo mi = markets[marketId];
        mi.baseRate = _baseRate;
        mi.utilizationMultiplier = _utilizationMultiplier;
        mi.reserveFactor = _reserveFactor;
        mi.collateralFactor = _collateralFactor;
        mi.liquidationMultiplier = _liquidationMultiplier;
        if (mi.vTokenBalance == 0) {
            mi.exchangeRate = _exchangeRate;
        }

        markets[marketId] = mi;
        MarketDelta marketDelta;

        _acquireInterest(marketId);
        _updateMarketDelta(marketId, marketDelta);
        _updateExchangeRate(marketId);

        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function updateModulesCache}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=203]
    function updateModulesCache() external view override onlyOwner {
        tvm.rawReserve(msg.value, 2);
        uint128 valueToTransfer = msg.value / (moduleAmount + 1);
        for ((, address module) : modules) {
            IContractStateCache(module).updateCache{
                value: valueToTransfer
            }(_owner, markets, tokenPrices);
        }
    }
\end{lstlisting}

\subsection{Function upgradeContractCode}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=44]
    function upgradeContractCode(TvmCell code, TvmCell updateParams, uint32 codeVersion) override external canUpgrade {
        tvm.accept();

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade(
            _owner,
            userAccountManager,
            walletController,
            oracle,
            markets,
            tokenPrices,
            modules,
            updateParams,
            codeVersion
        );
    }
\end{lstlisting}

\subsection{Function withdrawExtraTons}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=231]
    function withdrawExtraTons(uint128 amount) external override onlyOwner {
        tvm.accept();
        address(_owner).transfer({flag: 1, value: amount});
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function \_{}acquireInterest}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=126]
    function _acquireInterest(uint32 marketId) internal {
        MarketInfo mi = markets[marketId];
        uint256 dt = now - mi.lastUpdateTime;
        if (
            (markets[marketId].realTokenBalance != 0 ) ||
            (markets[marketId].totalBorrowed != 0)
        ) {
            fraction borrowRate = MarketOperations.calculateBorrowInterestRate(mi.baseRate, mi.realTokenBalance, mi.totalBorrowed, mi.utilizationMultiplier);
            borrowRate = borrowRate.simplify();
            fraction simpleInterestFactor = borrowRate.fNumMul(dt);
            fraction newIndex = simpleInterestFactor.fNumAdd(1);
            newIndex = mi.index.fMul(newIndex);
            newIndex = newIndex.simplify();
            fraction finterestAccumulated = mi.totalBorrowed.numFMul(simpleInterestFactor);
            uint256 interestAccumulated = finterestAccumulated.toNum();
            fraction freservesDelta = interestAccumulated.numFMul(mi.reserveFactor);
            uint256 totalBorrowNew = mi.totalBorrowed + interestAccumulated;
            uint256 totalReservesNew = mi.totalReserve + freservesDelta.toNum();
            mi.index = newIndex;
            mi.totalBorrowed = totalBorrowNew;
            mi.totalReserve = totalReservesNew;
            markets[marketId] = mi;
        }
        markets[marketId].lastUpdateTime = now;
    }
\end{lstlisting}

\subsection{Function \_{}createOperationUpdatePayload}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=405]
    function _createOperationUpdatePayload(uint8 operationId, uint32 marketId, TvmCell args) internal pure returns (TvmCell payload) {
        TvmBuilder tb;
        tb.store(operationId);
        tb.store(marketId);
        tb.storeRef(args);
        return tb.toCell();
    }
\end{lstlisting}

\subsection{Function \_{}createUpdatedIndexes}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=399]
    function _createUpdatedIndexes() internal view returns(mapping(uint32 => fraction) updatedIndexes) {
        for ((uint32 marketId, MarketInfo mi) : markets) {
            updatedIndexes[marketId] = mi.index;
        }
    }
\end{lstlisting}

\subsection{Function \_{}updateAllMarkets}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=118]
    function _updateAllMarkets() internal {
        for ((uint32 marketId,) : markets) {
            _acquireInterest(marketId);
            _updateExchangeRate(marketId);
        }
    }
\end{lstlisting}

\subsection{Function \_{}updateAllPrices}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=447]
    function _updateAllPrices(TvmCell payload) internal view {
        IOracleReturnPrices(oracle).getAllTokenPrices{
            flag: MsgFlag.REMAINING_GAS,
            callback: this.receiveAllUpdatedPrices
        }(payload);
    }
\end{lstlisting}

\subsection{Function \_{}updateExchangeRate}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=190]
    function _updateExchangeRate(uint32 marketId) internal {
        if (markets[marketId].vTokenBalance != 0) {
            fraction exchangeRate = MarketOperations.calculateExchangeRate(
                markets[marketId].realTokenBalance,
                markets[marketId].totalBorrowed,
                markets[marketId].totalReserve,
                markets[marketId].vTokenBalance
            );
            markets[marketId].exchangeRate = exchangeRate;
        }
    }
\end{lstlisting}

\subsection{Function \_{}updateMarketDelta}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=152]
    function _updateMarketDelta(uint32 marketId, MarketDelta marketDelta) internal {
        if (
            marketDelta.realTokenBalance.delta != 0 &&
            marketDelta.realTokenBalance.positive
        ) {
            markets[marketId].realTokenBalance += marketDelta.realTokenBalance.delta;
        } else {
            markets[marketId].realTokenBalance -= marketDelta.realTokenBalance.delta;
        }

        if (
            marketDelta.totalBorrowed.delta != 0 &&
            marketDelta.totalBorrowed.positive
        ) {
            markets[marketId].totalBorrowed += marketDelta.totalBorrowed.delta;
        } else {
            markets[marketId].totalBorrowed -= marketDelta.totalBorrowed.delta;
        }

        if (
            marketDelta.vTokenBalance.delta != 0 &&
            marketDelta.vTokenBalance.positive
        ) {
            markets[marketId].vTokenBalance += marketDelta.vTokenBalance.delta;
        } else {
            markets[marketId].vTokenBalance -= marketDelta.vTokenBalance.delta;
        }

        if (
            marketDelta.totalReserve.delta != 0 &&
            marketDelta.totalReserve.positive
        ) {
            markets[marketId].totalReserve += marketDelta.totalReserve.delta;
        } else {
            markets[marketId].totalReserve -= marketDelta.totalReserve.delta;
        }
    }
\end{lstlisting}

\subsection{Function onCodeUpgrade}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=64]
    function onCodeUpgrade(
        address owner,
        address _userAccountManager,
        address _walletController,
        address _oracle,
        mapping(uint32 => MarketInfo) _markets,
        mapping(address => fraction) _tokenPrices,
        mapping(uint8 => address) _modules,
        TvmCell,
        uint32 _codeVersion
    ) private {
        tvm.resetStorage();
        contractCodeVersion = _codeVersion;
        _owner = owner;
        userAccountManager = _userAccountManager;
        walletController = _walletController;
        oracle = _oracle;
        markets = _markets;
        tokenPrices = _tokenPrices;
        modules = _modules;
        moduleAmount = 0;
        for ((, address module): modules) {
            moduleAmount += 1;
            isModule[module] = true;
        }

        for ((uint32 marketId, MarketInfo market): markets) {
            createdMarkets[marketId] = true;
            tokensToMarkets[market.token] = marketId;
            realTokenRoots[market.token] = true;
        }
    }
\end{lstlisting}

\subsection{Function performOperation}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=361]
    function performOperation(TvmCell args) internal view {
        TvmSlice ts = args.toSlice();

        uint8 operationId = ts.decode(uint8);
        if (operationId != OperationCodes.NO_OP) {
            uint32 marketId = ts.decode(uint32);
            TvmCell moduleArgs = ts.loadRef();
            IModule(modules[operationId]).performAction{
                flag: MsgFlag.REMAINING_GAS
            }(marketId, moduleArgs, markets, tokenPrices);
        } else {
            address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
        }
    }
\end{lstlisting}

\subsection{Function updatePrice}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=428]
    function updatePrice(address tokenRoot, TvmCell payload) internal view {
        IOracleReturnPrices(oracle).getTokenPrice{
            flag: MsgFlag.REMAINING_GAS,
            callback: this.receiveUpdatedPrice
        }(tokenRoot, payload);
    }
\end{lstlisting}
\paragraph{Some functions inherited by using}
