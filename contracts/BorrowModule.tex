
\chapter{Contract BorrowModule}

\minitoc

\section{Overview}


In file {\tt BorrowModule.sol}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
IRoles & \\\hline
IModule & \\\hline
IContractStateCache & \\\hline
IContractAddressSG & \\\hline
IBorrowModule & \\\hline
IUpgradableContract & \\\hline
\end{tabular}


\section{Event Definitions}


\begin{lstlisting}[firstnumber=16]
    event TokenBorrow(uint32 marketId, MarketDelta marketDelta, address tonWallet, uint256 tokensBorrowed);
\end{lstlisting}

\section{Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
address & marketAddress &  \\\hline
 & & used in @6.BorrowModule.upgradeContractCode\\\hline
 & & assigned in @6.BorrowModule.setMarketAddress\\\hline
 & & used in @6.BorrowModule.setMarketAddress\\\hline
 & & assigned in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.getContractAddresses\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
address & userAccountManager &  \\\hline
 & & used in @6.BorrowModule.upgradeContractCode\\\hline
 & & assigned in @6.BorrowModule.setUserAccountManager\\\hline
 & & used in @6.BorrowModule.setUserAccountManager\\\hline
 & & used in @6.BorrowModule.resumeOperation\\\hline
 & & used in @6.BorrowModule.performAction\\\hline
 & & assigned in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.getContractAddresses\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
uint32 & contractCodeVersion &  \\\hline
 & & assigned in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.onCodeUpgrade\\\hline
mapping (uint32 =$>$ MarketInfo) & marketInfo &  \\\hline
 & & used in @6.BorrowModule.upgradeContractCode\\\hline
 & & assigned in @6.BorrowModule.updateCache\\\hline
 & & used in @6.BorrowModule.updateCache\\\hline
 & & used in @6.BorrowModule.resumeOperation\\\hline
 & & assigned in @6.BorrowModule.resumeOperation\\\hline
 & & used in @6.BorrowModule.resumeOperation\\\hline
 & & assigned in @6.BorrowModule.performAction\\\hline
 & & used in @6.BorrowModule.performAction\\\hline
 & & assigned in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.getModuleState\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.\_{}createUpdatedIndexes\\\hline
mapping (address =$>$ fraction) & tokenPrices &  \\\hline
 & & used in @6.BorrowModule.upgradeContractCode\\\hline
 & & assigned in @6.BorrowModule.updateCache\\\hline
 & & used in @6.BorrowModule.updateCache\\\hline
 & & assigned in @6.BorrowModule.resumeOperation\\\hline
 & & used in @6.BorrowModule.resumeOperation\\\hline
 & & assigned in @6.BorrowModule.performAction\\\hline
 & & used in @6.BorrowModule.performAction\\\hline
 & & assigned in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.onCodeUpgrade\\\hline
 & & used in @6.BorrowModule.getModuleState\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
 & & used in @6.BorrowModule.borrowTokensFromMarket\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=9]
    address marketAddress;
\end{lstlisting}

\begin{lstlisting}[firstnumber=10]
    address userAccountManager;
\end{lstlisting}

\begin{lstlisting}[firstnumber=11]
    uint32 public contractCodeVersion;
\end{lstlisting}

\begin{lstlisting}[firstnumber=13]
    mapping (uint32 => MarketInfo) marketInfo;
\end{lstlisting}

\begin{lstlisting}[firstnumber=14]
    mapping (address => fraction) tokenPrices;
\end{lstlisting}

\section{Modifier Definitions}


\subsection{Modifier onlyUserAccountManager}


\begin{lstlisting}[firstnumber=175]
    modifier onlyUserAccountManager() {
        require(msg.sender == userAccountManager);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyMarket}


\begin{lstlisting}[firstnumber=180]
    modifier onlyMarket() {
        require(msg.sender == marketAddress);
        tvm.rawReserve(msg.value, 2);
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\issueCritical{Constructor for BorrowModule (fake)}{loren ipsum  loren ipsum  loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum

loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum
loren ipsum loren ipsum loren ipsum }
\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=18]
    constructor(address _newOwner) public {
        tvm.accept();
        _owner = _newOwner;
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function borrowTokensFromMarket}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=105]
    function borrowTokensFromMarket(
        address tonWallet,
        address userTip3Wallet,
        uint256 tokensToBorrow,
        uint32 marketId,
        mapping (uint32 => uint256) supplyInfo,
        mapping (uint32 => BorrowInfo) borrowInfo
    ) external override onlyUserAccountManager {
        tvm.rawReserve(msg.value, 2);
        mapping(uint32 => MarketDelta) marketsDelta;
        MarketDelta marketDelta;
        
        // Borrow:
        // 1. Check that market has enough tokens for lending
        // 2. Calculate user account health
        // 3. Calculate USD value of tokens to borrow
        // 4. Check if there is enough (collateral - borrowed) for new token borrow
        // 5. Increase user's borrowed amount

        if (tokensToBorrow < marketInfo[marketId].realTokenBalance - marketInfo[marketId].totalReserve) {
            fraction accountHealth = Utilities.calculateSupplyBorrow(supplyInfo, borrowInfo, marketInfo, tokenPrices);
            if (accountHealth.nom > accountHealth.denom) {
                uint256 healthDelta = accountHealth.nom - accountHealth.denom;
                fraction tmp = healthDelta.numFMul(tokenPrices[marketInfo[marketId].token]);
                uint256 possibleTokenWithdraw = tmp.toNum();
                if (possibleTokenWithdraw >= tokensToBorrow) {
                    marketDelta.totalBorrowed.delta = tokensToBorrow;
                    marketDelta.totalBorrowed.positive = true;
                    marketDelta.realTokenBalance.delta = tokensToBorrow;
                    marketDelta.realTokenBalance.positive = false;

                    marketsDelta[marketId] = marketDelta;

                    TvmBuilder tb;
                    tb.store(marketId);
                    tb.store(tonWallet);
                    tb.store(userTip3Wallet);
                    tb.store(tokensToBorrow);

                    emit TokenBorrow(marketId, marketDelta, tonWallet, tokensToBorrow);

                    IContractStateCacheRoot(marketAddress).receiveCacheDelta{
                        flag: MsgFlag.REMAINING_GAS
                    }(marketsDelta, tb.toCell());
                } else {
                    IUAMUserAccount(userAccountManager).writeBorrowInformation{
                        flag: MsgFlag.REMAINING_GAS
                    }(tonWallet, userTip3Wallet, 0, marketId, marketInfo[marketId].index);
                }
            } else {
                IUAMUserAccount(userAccountManager).writeBorrowInformation{
                    flag: MsgFlag.REMAINING_GAS
                }(tonWallet, userTip3Wallet, 0, marketId, marketInfo[marketId].index);
            }
        } else {
            address(tonWallet).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
        }
    }
\end{lstlisting}

\subsection{Function getContractAddresses}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=77]
    function getContractAddresses() external override view responsible returns(address _owner, address _marketAddress, address _userAccountManager) {
        return {flag: MsgFlag.REMAINING_GAS} (_owner, marketAddress, userAccountManager);
    }
\end{lstlisting}

\subsection{Function getModuleState}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=61]
    function getModuleState() external override view returns(mapping(uint32 => MarketInfo), mapping(address => fraction)) {
        return(marketInfo, tokenPrices);
    }
\end{lstlisting}

\subsection{Function performAction}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=87]
    function performAction(uint32 marketId, TvmCell args, mapping (uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        tvm.rawReserve(msg.value, 2);
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        TvmSlice ts = args.toSlice();
        (address tonWallet, address userTip3Wallet, uint256 tokensToBorrow) = ts.decode(address, address, uint256);
        mapping(uint32 => fraction) updatedIndexes = _createUpdatedIndexes();
        IUAMUserAccount(userAccountManager).updateUserIndexes{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, userTip3Wallet, tokensToBorrow, marketId, updatedIndexes);
    }
\end{lstlisting}

\subsection{Function resumeOperation}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=164]
    function resumeOperation(TvmCell args, mapping(uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        tvm.rawReserve(msg.value, 2);
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        TvmSlice ts = args.toSlice();
        (uint32 marketId, address tonWallet, address userTip3Wallet, uint256 tokensToBorrow) = ts.decode(uint32, address, address, uint256);
        IUAMUserAccount(userAccountManager).writeBorrowInformation{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, userTip3Wallet, tokensToBorrow, marketId, marketInfo[marketId].index);
    }
\end{lstlisting}

\subsection{Function sendActionId}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=57]
    function sendActionId() external override view responsible returns(uint8) {
        return {flag: MsgFlag.REMAINING_GAS} OperationCodes.BORROW_TOKENS;
    }
\end{lstlisting}

\subsection{Function setMarketAddress}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=65]
    function setMarketAddress(address _marketAddress) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        marketAddress = _marketAddress;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function setUserAccountManager}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=71]
    function setUserAccountManager(address _userAccountManager) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        userAccountManager = _userAccountManager;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function updateCache}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=81]
    function updateCache(address tonWallet, mapping (uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        tonWallet.transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function upgradeContractCode}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=23]
    function upgradeContractCode(TvmCell code, TvmCell updateParams, uint32 codeVersion) external override canUpgrade {
        tvm.rawReserve(msg.value, 2);

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade (
            _owner,
            marketAddress,
            userAccountManager,
            marketInfo,
            tokenPrices,
            codeVersion
        );
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function \_{}createUpdatedIndexes}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=99]
    function _createUpdatedIndexes() internal view returns(mapping(uint32 => fraction) updatedIndexes) {
        for ((uint32 marketId, MarketInfo mi): marketInfo) {
            updatedIndexes[marketId] = mi.index;
        }
    }
\end{lstlisting}

\subsection{Function onCodeUpgrade}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=39]
    function onCodeUpgrade(
        address owner,
        address _marketAddress,
        address _userAccountManager,
        mapping(uint32 => MarketInfo) _marketInfo,
        mapping(address => fraction) _tokenPrices,
        uint32 _codeVersion
    ) private {
        tvm.accept();
        tvm.resetStorage();
        _owner = owner;
        marketAddress = _marketAddress;
        userAccountManager = _userAccountManager;
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        contractCodeVersion = _codeVersion;
    }
\end{lstlisting}
\paragraph{Some functions inherited by using}
