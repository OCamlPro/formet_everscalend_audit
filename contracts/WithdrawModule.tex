
\chapter{Contract WithdrawModule}

\minitoc

\section{Overview}


In file {\tt WithdrawModule.sol}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
IRoles & \\\hline
IModule & \\\hline
IContractStateCache & \\\hline
IContractAddressSG & \\\hline
IWithdrawModule & \\\hline
IUpgradableContract & \\\hline
\end{tabular}


\section{Event Definitions}


\begin{lstlisting}[firstnumber=18]
    event TokenWithdraw(uint32 marketId, MarketDelta marketDelta, address tonWallet, uint256 vTokensWithdrawn, uint256 realTokensWithdrawn);
\end{lstlisting}

\section{Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
address & marketAddress &  \\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.upgradeContractCode\\\hline
 & & assigned in @10.WithdrawModule.setMarketAddress\\\hline
 & & used in @10.WithdrawModule.setMarketAddress\\\hline
 & & assigned in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.getContractAddresses\\\hline
address & userAccountManager &  \\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.upgradeContractCode\\\hline
 & & assigned in @10.WithdrawModule.setUserAccountManager\\\hline
 & & used in @10.WithdrawModule.setUserAccountManager\\\hline
 & & used in @10.WithdrawModule.resumeOperation\\\hline
 & & used in @10.WithdrawModule.performAction\\\hline
 & & assigned in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.getContractAddresses\\\hline
uint32 & contractCodeVersion &  \\\hline
 & & assigned in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.onCodeUpgrade\\\hline
mapping (uint32 =$>$ MarketInfo) & marketInfo &  \\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.upgradeContractCode\\\hline
 & & assigned in @10.WithdrawModule.updateCache\\\hline
 & & used in @10.WithdrawModule.updateCache\\\hline
 & & assigned in @10.WithdrawModule.resumeOperation\\\hline
 & & used in @10.WithdrawModule.resumeOperation\\\hline
 & & assigned in @10.WithdrawModule.performAction\\\hline
 & & used in @10.WithdrawModule.performAction\\\hline
 & & assigned in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.getModuleState\\\hline
 & & used in @10.WithdrawModule.\_{}createUpdatedIndexes\\\hline
mapping (address =$>$ fraction) & tokenPrices &  \\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.withdrawTokensFromMarket\\\hline
 & & used in @10.WithdrawModule.upgradeContractCode\\\hline
 & & assigned in @10.WithdrawModule.updateCache\\\hline
 & & used in @10.WithdrawModule.updateCache\\\hline
 & & assigned in @10.WithdrawModule.resumeOperation\\\hline
 & & used in @10.WithdrawModule.resumeOperation\\\hline
 & & assigned in @10.WithdrawModule.performAction\\\hline
 & & used in @10.WithdrawModule.performAction\\\hline
 & & assigned in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.onCodeUpgrade\\\hline
 & & used in @10.WithdrawModule.getModuleState\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=11]
    address marketAddress;
\end{lstlisting}

\begin{lstlisting}[firstnumber=12]
    address userAccountManager;
\end{lstlisting}

\begin{lstlisting}[firstnumber=13]
    uint32 public contractCodeVersion;
\end{lstlisting}

\begin{lstlisting}[firstnumber=15]
    mapping (uint32 => MarketInfo) marketInfo;
\end{lstlisting}

\begin{lstlisting}[firstnumber=16]
    mapping (address => fraction) tokenPrices;
\end{lstlisting}

\section{Modifier Definitions}


\subsection{Modifier onlyMarket}


\begin{lstlisting}[firstnumber=190]
    modifier onlyMarket() {
        require(msg.sender == marketAddress);
        tvm.rawReserve(msg.value, 2);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyUserAccountManager}


\begin{lstlisting}[firstnumber=196]
    modifier onlyUserAccountManager() {
        require(msg.sender == userAccountManager);
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\issueCritical{Constructor for WithdrawModule (fake)}{loren ipsum  loren ipsum  loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum

loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum
loren ipsum loren ipsum loren ipsum }
\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=20]
    constructor(address _newOwner) public {
        tvm.accept();
        _owner = _newOwner;
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function getContractAddresses}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=79]
    function getContractAddresses() external override view responsible returns(address _owner, address _marketAddress, address _userAccountManager) {
        return {flag: MsgFlag.REMAINING_GAS} (_owner, marketAddress, userAccountManager);
    }
\end{lstlisting}

\subsection{Function getModuleState}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=63]
    function getModuleState() external override view returns(mapping(uint32 => MarketInfo), mapping(address => fraction)) {
        return(marketInfo, tokenPrices);
    }
\end{lstlisting}

\subsection{Function performAction}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=89]
    function performAction(uint32 marketId, TvmCell args, mapping (uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        TvmSlice ts = args.toSlice();
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        (address tonWallet, address userTip3Wallet, uint256 tokensToWithdraw) = ts.decode(address, address, uint256);
        mapping(uint32 => fraction) updatedIndexes = _createUpdatedIndexes();
        IUAMUserAccount(userAccountManager).requestWithdrawInfo{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, userTip3Wallet, tokensToWithdraw, marketId, updatedIndexes);
    }
\end{lstlisting}

\subsection{Function resumeOperation}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=177]
    function resumeOperation(TvmCell args, mapping(uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        tvm.rawReserve(msg.value, 2);
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        TvmSlice ts = args.toSlice();
        (uint32 marketId, address tonWallet, address userTip3Wallet) = ts.decode(uint32, address, address);
        TvmSlice values = ts.loadRefAsSlice();
        (uint256 tokensToWithdraw, uint256 tokensToSend) = values.decode(uint256, uint256);
        IUAMUserAccount(userAccountManager).writeWithdrawInfo{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, userTip3Wallet, marketId, tokensToWithdraw, tokensToSend);
    }
\end{lstlisting}

\subsection{Function sendActionId}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=59]
    function sendActionId() external override view responsible returns(uint8) {
        return {flag: MsgFlag.REMAINING_GAS} OperationCodes.WITHDRAW_TOKENS;
    }
\end{lstlisting}

\subsection{Function setMarketAddress}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=67]
    function setMarketAddress(address _marketAddress) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        marketAddress = _marketAddress;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function setUserAccountManager}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=73]
    function setUserAccountManager(address _userAccountManager) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        userAccountManager = _userAccountManager;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function updateCache}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=83]
    function updateCache(address tonWallet, mapping (uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        tonWallet.transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function upgradeContractCode}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=25]
    function upgradeContractCode(TvmCell code, TvmCell updateParams, uint32 codeVersion) external override canUpgrade {
        tvm.rawReserve(msg.value, 2);

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade (
            _owner,
            marketAddress,
            userAccountManager,
            marketInfo,
            tokenPrices,
            codeVersion
        );
    }
\end{lstlisting}

\subsection{Function withdrawTokensFromMarket}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=106]
    function withdrawTokensFromMarket(
        address tonWallet, 
        address userTip3Wallet,
        uint256 tokensToWithdraw, 
        uint32 marketId, 
        mapping(uint32 => uint256) supplyInfo,
        mapping(uint32 => BorrowInfo) borrowInfo
    ) external override onlyUserAccountManager {
        tvm.rawReserve(msg.value, 2);
        MarketDelta marketDelta;
        mapping(uint32 => MarketDelta) marketsDelta;

        MarketInfo mi = marketInfo[marketId];

        // For token withdraw:
        // 1. Calculate account health
        // 2. Calculate USD amount for withdraw token
        // 3. Check if user can afford to withdraw required amount of real tokens

        fraction accountHealth = Utilities.calculateSupplyBorrow(supplyInfo, borrowInfo, marketInfo, tokenPrices);

        fraction fTokensToSend = tokensToWithdraw.numFMul(mi.exchangeRate);
        fraction fTokensToSendUSD = fTokensToSend.fDiv(tokenPrices[marketInfo[marketId].token]);

        // Check user balance in tokens just in case
        // There will be lock at user account for operation, unified for all operations
        // As all operations are finished with account health check, account will unlock after
        // Updating indexes
        if (
            (accountHealth.nom > accountHealth.denom) &&
            (supplyInfo[marketId] >= tokensToWithdraw)
        ) {
            if (
                accountHealth.nom - accountHealth.denom >= fTokensToSendUSD.toNum() &&
                fTokensToSend.toNum() <= mi.realTokenBalance - mi.totalReserve
            ) {
                uint256 tokensToSend = fTokensToSend.toNum();

                marketDelta.realTokenBalance.delta = tokensToSend;
                marketDelta.realTokenBalance.positive = false;
                marketDelta.vTokenBalance.delta = tokensToWithdraw;
                marketDelta.vTokenBalance.positive = false;

                marketsDelta[marketId] = marketDelta;

                emit TokenWithdraw(marketId, marketDelta, tonWallet, tokensToWithdraw, tokensToSend);

                TvmBuilder tb;
                tb.store(marketId);
                tb.store(tonWallet);
                tb.store(userTip3Wallet);
                TvmBuilder valueStorate;
                valueStorate.store(tokensToWithdraw);
                valueStorate.store(tokensToSend);
                tb.store(valueStorate.toCell());

                IContractStateCacheRoot(marketAddress).receiveCacheDelta{
                    flag: MsgFlag.REMAINING_GAS
                }(marketsDelta, tb.toCell());
            } else {
                IUAMUserAccount(userAccountManager).requestUserAccountHealthCalculation{
                    flag: MsgFlag.REMAINING_GAS
                }(tonWallet);
            }
        } else {
            IUAMUserAccount(userAccountManager).requestUserAccountHealthCalculation{
                flag: MsgFlag.REMAINING_GAS
            }(tonWallet);
        }
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function \_{}createUpdatedIndexes}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=100]
    function _createUpdatedIndexes() internal view returns(mapping(uint32 => fraction) updatedIndexes) {
        for ((uint32 marketId, MarketInfo mi): marketInfo) {
            updatedIndexes[marketId] = mi.index;
        }
    }
\end{lstlisting}

\subsection{Function onCodeUpgrade}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=41]
    function onCodeUpgrade(
        address owner,
        address _marketAddress,
        address _userAccountManager,
        mapping(uint32 => MarketInfo) _marketInfo,
        mapping(address => fraction) _tokenPrices,
        uint32 _codeVersion
    ) private {
        tvm.accept();
        tvm.resetStorage();
        _owner = owner;
        marketAddress = _marketAddress;
        userAccountManager = _userAccountManager;
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        contractCodeVersion = _codeVersion;
    }
\end{lstlisting}
\paragraph{Some functions inherited by using}
