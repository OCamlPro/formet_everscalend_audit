
\chapter{Contract LiquidationModule}

\minitoc

\section{Overview}


In file {\tt LiquidationModule.sol}

\section{Contract Inheritance}


\noindent\begin{tabular}{|l|p{5cm}|}\hline
IRoles & \\\hline
IModule & \\\hline
IContractStateCache & \\\hline
IContractAddressSG & \\\hline
ILiquidationModule & \\\hline
IUpgradableContract & \\\hline
\end{tabular}


\section{Event Definitions}


\begin{lstlisting}[firstnumber=16]
    event TokensLiquidated(uint32 marketId, mapping(uint32 => MarketDelta) marketDeltas, address liquidator, address targetUser, uint256 tokensLiquidated, uint256 vTokensSeized);
\end{lstlisting}

\section{Variable Definitions}


\ifsoltables
\noindent\begin{tabular}{|l|l|p{5cm}|}\hline
address & marketAddress &  \\\hline
 & & used in @7.LiquidationModule.upgradeContractCode\\\hline
 & & assigned in @7.LiquidationModule.setMarketAddress\\\hline
 & & used in @7.LiquidationModule.setMarketAddress\\\hline
 & & assigned in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.getContractAddresses\\\hline
address & userAccountManager &  \\\hline
 & & used in @7.LiquidationModule.upgradeContractCode\\\hline
 & & assigned in @7.LiquidationModule.setUserAccountManager\\\hline
 & & used in @7.LiquidationModule.setUserAccountManager\\\hline
 & & used in @7.LiquidationModule.resumeOperation\\\hline
 & & used in @7.LiquidationModule.performAction\\\hline
 & & assigned in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.getContractAddresses\\\hline
uint32 & contractCodeVersion &  \\\hline
 & & assigned in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.onCodeUpgrade\\\hline
mapping (uint32 =$>$ MarketInfo) & marketInfo &  \\\hline
 & & used in @7.LiquidationModule.upgradeContractCode\\\hline
 & & assigned in @7.LiquidationModule.updateCache\\\hline
 & & used in @7.LiquidationModule.updateCache\\\hline
 & & assigned in @7.LiquidationModule.resumeOperation\\\hline
 & & used in @7.LiquidationModule.resumeOperation\\\hline
 & & assigned in @7.LiquidationModule.performAction\\\hline
 & & used in @7.LiquidationModule.performAction\\\hline
 & & assigned in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.getModuleState\\\hline
 & & used in @7.LiquidationModule.\_{}createUpdatedIndexes\\\hline
mapping (address =$>$ fraction) & tokenPrices &  \\\hline
 & & used in @7.LiquidationModule.upgradeContractCode\\\hline
 & & assigned in @7.LiquidationModule.updateCache\\\hline
 & & used in @7.LiquidationModule.updateCache\\\hline
 & & assigned in @7.LiquidationModule.resumeOperation\\\hline
 & & used in @7.LiquidationModule.resumeOperation\\\hline
 & & assigned in @7.LiquidationModule.performAction\\\hline
 & & used in @7.LiquidationModule.performAction\\\hline
 & & assigned in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.onCodeUpgrade\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.liquidate\\\hline
 & & used in @7.LiquidationModule.getModuleState\\\hline
\end{tabular}
\fi


\begin{lstlisting}[firstnumber=9]
    address marketAddress;
\end{lstlisting}

\begin{lstlisting}[firstnumber=10]
    address userAccountManager;
\end{lstlisting}

\begin{lstlisting}[firstnumber=11]
    uint32 public contractCodeVersion;
\end{lstlisting}

\begin{lstlisting}[firstnumber=13]
    mapping (uint32 => MarketInfo) marketInfo;
\end{lstlisting}

\begin{lstlisting}[firstnumber=14]
    mapping (address => fraction) tokenPrices;
\end{lstlisting}

\section{Modifier Definitions}


\subsection{Modifier onlyUserAccountManager}


\begin{lstlisting}[firstnumber=235]
    modifier onlyUserAccountManager() {
        require(msg.sender == userAccountManager);
        _;
    }
\end{lstlisting}

\subsection{Modifier onlyMarket}


\begin{lstlisting}[firstnumber=240]
    modifier onlyMarket() {
        require(msg.sender == marketAddress);
        tvm.rawReserve(msg.value, 2);
        _;
    }
\end{lstlisting}

\section{Constructor Definitions}


\subsection{Constructor}

\issueCritical{Constructor for LiquidationModule (fake)}{loren ipsum  loren ipsum  loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum

loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum loren ipsum
loren ipsum loren ipsum loren ipsum }
\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=18]
    constructor(address _newOwner) public {
        tvm.accept();
        _owner = _newOwner;
    }
\end{lstlisting}

\section{Public Method Definitions}


\subsection{Function getContractAddresses}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=77]
    function getContractAddresses() external override view responsible returns(address _owner, address _marketAddress, address _userAccountManager) {
        return {flag: MsgFlag.REMAINING_GAS} (_owner, marketAddress, userAccountManager);
    }
\end{lstlisting}

\subsection{Function getModuleState}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=61]
    function getModuleState() external override view returns(mapping(uint32 => MarketInfo), mapping(address => fraction)) {
        return(marketInfo, tokenPrices);
    }
\end{lstlisting}

\subsection{Function liquidate}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=101]
    function liquidate(
        address tonWallet, 
        address targetUser, 
        address tip3UserWallet, 
        uint32 marketId, 
        uint32 marketToLiquidate,
        uint256 tokensProvided, 
        mapping(uint32 => uint256) supplyInfo, 
        mapping(uint32 => BorrowInfo) borrowInfo
    ) external override onlyUserAccountManager {
        tvm.rawReserve(msg.value, 2);
        // Liquidation:
        // 1. Calculate user account health to check if liquidation is required
        // 2. Calculate max values
        // 3. Choose minimal value of all max values
        // 4. Based on min value calculate rest of parameters, it is guaranteed that:
        // - User will not exceed tokens that he provided for liquidation (providingLimit)
        // - User will not exceed tokens that are available for liquidation (borrowLimit)
        // - User will not exceed vToken balance of user that is liquidated (vTokenLimit)

        fraction health = Utilities.calculateSupplyBorrow(supplyInfo, borrowInfo, marketInfo, tokenPrices);
        if (health.nom <= health.denom) {
            uint256 tokensToLiquidate = math.min(
                borrowInfo[marketId].tokensBorrowed,
                tokensProvided
            );

            // Calculating USD value of liquidation
            fraction ftokensToLiquidateUSD = tokensToLiquidate.numFMul(marketInfo[marketId].liquidationMultiplier);
            ftokensToLiquidateUSD = ftokensToLiquidateUSD.fDiv(tokenPrices[marketInfo[marketId].token]);

            // Calculating USD value of collateral
            fraction fvTokensCollateralUSD = supplyInfo[marketToLiquidate].numFMul(marketInfo[marketToLiquidate].exchangeRate);
            fvTokensCollateralUSD = fvTokensCollateralUSD.fDiv(tokenPrices[marketInfo[marketToLiquidate].token]);

            uint256 tokensToSeize;
            uint256 tokensToReturn;
            uint256 tokensFromReserve;

            // Calculating how much of collateral tokens to seize
            fraction fvTokensCollateral = fvTokensCollateralUSD.getMin(ftokensToLiquidateUSD);
            fraction ftokensToSeize = fvTokensCollateral.fMul(tokenPrices[marketInfo[marketToLiquidate].token]);
            ftokensToSeize = ftokensToSeize.fDiv(marketInfo[marketToLiquidate].exchangeRate);
            tokensToSeize = ftokensToSeize.toNum();

            tokensToReturn = tokensProvided - tokensToLiquidate;
            mapping(uint32 => MarketDelta) marketDeltas;
            MarketDelta collateralMarketDelta;
            MarketDelta liquidationMarketDelta;

            liquidationMarketDelta.totalBorrowed.delta = tokensToLiquidate;
            liquidationMarketDelta.totalBorrowed.positive = false;
            liquidationMarketDelta.realTokenBalance.delta = tokensToLiquidate;
            liquidationMarketDelta.realTokenBalance.positive = true;

            if (fvTokensCollateralUSD.lessThan(ftokensToLiquidateUSD)) {
                // Using reserves from market to compensate liquidity absence
                fraction freservesUsageUSD = ftokensToLiquidateUSD.fSub(fvTokensCollateralUSD);
                freservesUsageUSD = freservesUsageUSD.simplify();
                fraction freservesUsageTokens = freservesUsageUSD.fMul(tokenPrices[marketInfo[marketToLiquidate].token]);
                uint256 reservesUsageTokens = freservesUsageTokens.toNum();
                if (reservesUsageTokens < marketInfo[marketId].totalReserve) {
                    tokensFromReserve = reservesUsageTokens;
                    collateralMarketDelta.totalReserve.delta = tokensFromReserve;
                    collateralMarketDelta.totalReserve.positive = false;
                } else {
                    // abort liquidation
                    IUAMUserAccount(userAccountManager).requestTokenPayout{
                        flag: MsgFlag.REMAINING_GAS
                    }(
                        tonWallet, tip3UserWallet, marketId, tokensProvided
                    );
                    tvm.exit();
                }
            }

            marketDeltas[marketId] = liquidationMarketDelta;
            marketDeltas[marketToLiquidate] = collateralMarketDelta;

            emit TokensLiquidated(marketId, marketDeltas, tonWallet, targetUser, tokensToLiquidate, tokensToSeize);

            BorrowInfo userBorrowInfo = BorrowInfo(borrowInfo[marketId].tokensBorrowed - tokensToLiquidate, marketInfo[marketId].index);

            TvmBuilder tb;
            TvmBuilder addressStorage;
            addressStorage.store(tonWallet);
            addressStorage.store(targetUser);
            addressStorage.store(tip3UserWallet);
            TvmBuilder valueStorage;
            valueStorage.store(marketId);
            valueStorage.store(marketToLiquidate);
            valueStorage.store(tokensToSeize);
            valueStorage.store(tokensToReturn);
            valueStorage.store(tokensFromReserve);
            TvmBuilder borrowInfoStorage;
            borrowInfoStorage.store(userBorrowInfo);
            tb.store(addressStorage.toCell());
            tb.store(valueStorage.toCell());
            tb.store(borrowInfoStorage.toCell());

            IContractStateCacheRoot(marketAddress).receiveCacheDelta{
                flag: MsgFlag.REMAINING_GAS
            }(marketDeltas, tb.toCell());
        } else {
            IUAMUserAccount(userAccountManager).requestTokenPayout{
                flag: MsgFlag.REMAINING_GAS
            }(
                tonWallet, tip3UserWallet, marketId, tokensProvided
            );
        }
    }
\end{lstlisting}

\subsection{Function performAction}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=87]
    function performAction(uint32 marketId, TvmCell args, mapping (uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        tvm.rawReserve(msg.value, 2);
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        TvmSlice ts = args.toSlice();
        (address tonWallet, address targetUser, address tip3UserWallet) = ts.decode(address, address, address);
        TvmSlice amountTS = ts.loadRefAsSlice();
        (uint32 marketToLiquidate, uint256 tokenAmount) = amountTS.decode(uint32, uint256);
        mapping(uint32 => fraction) updatedIndexes = _createUpdatedIndexes();
        IUAMUserAccount(userAccountManager).requestLiquidationInformation{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, targetUser, tip3UserWallet, marketId, marketToLiquidate, tokenAmount, updatedIndexes);
    }
\end{lstlisting}

\subsection{Function resumeOperation}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=213]
    function resumeOperation(TvmCell args, mapping(uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        tvm.rawReserve(msg.value, 2);
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        TvmSlice ts = args.toSlice();
        TvmSlice addressStorage = ts.loadRefAsSlice();
        (address tonWallet, address targetUser, address tip3UserWallet) = addressStorage.decode(address, address, address);
        TvmSlice valueStorage = ts.loadRefAsSlice();
        (uint32 marketId, uint32 marketToLiquidate, uint256 tokensToSeize, uint256 tokensToReturn, uint256 tokensFromReserve) = valueStorage.decode(uint32, uint32, uint256, uint256, uint256);
        TvmSlice borrowInfoStorage = ts.loadRefAsSlice();
        (BorrowInfo borrowInfo) = borrowInfoStorage.decode(BorrowInfo);
        IUAMUserAccount(userAccountManager).seizeTokens{
            flag: MsgFlag.REMAINING_GAS
        }(tonWallet, targetUser, tip3UserWallet, marketId, marketToLiquidate, tokensToSeize, tokensToReturn, tokensFromReserve, borrowInfo);
    }
\end{lstlisting}

\subsection{Function sendActionId}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=57]
    function sendActionId() external override view responsible returns(uint8) {
        return {flag: MsgFlag.REMAINING_GAS} OperationCodes.LIQUIDATE_TOKENS;
    }
\end{lstlisting}

\subsection{Function setMarketAddress}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=65]
    function setMarketAddress(address _marketAddress) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        marketAddress = _marketAddress;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function setUserAccountManager}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=71]
    function setUserAccountManager(address _userAccountManager) external override canChangeParams {
        tvm.rawReserve(msg.value, 2);
        userAccountManager = _userAccountManager;
        address(_owner).transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function updateCache}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=81]
    function updateCache(address tonWallet, mapping (uint32 => MarketInfo) _marketInfo, mapping (address => fraction) _tokenPrices) external override onlyMarket {
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        tonWallet.transfer({value: 0, flag: MsgFlag.REMAINING_GAS});
    }
\end{lstlisting}

\subsection{Function upgradeContractCode}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=23]
    function upgradeContractCode(TvmCell code, TvmCell updateParams, uint32 codeVersion) external override canUpgrade {
        tvm.rawReserve(msg.value, 2);

        tvm.setcode(code);
        tvm.setCurrentCode(code);

        onCodeUpgrade (
            _owner,
            marketAddress,
            userAccountManager,
            marketInfo,
            tokenPrices,
            codeVersion
        );
    }
\end{lstlisting}

\section{Internal Method Definitions}


\subsection{Function \_{}createUpdatedIndexes}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=229]
    function _createUpdatedIndexes() internal view returns(mapping(uint32 => fraction) updatedIndexes) {
        for ((uint32 marketId, MarketInfo mi): marketInfo) {
            updatedIndexes[marketId] = mi.index;
        }
    }
\end{lstlisting}

\subsection{Function onCodeUpgrade}

\noindent\begin{itemize}
\item TODO
\end{itemize}

\begin{lstlisting}[firstnumber=39]
    function onCodeUpgrade(
        address owner,
        address _marketAddress,
        address _userAccountManager,
        mapping(uint32 => MarketInfo) _marketInfo,
        mapping(address => fraction) _tokenPrices,
        uint32 _codeVersion
    ) private {
        tvm.accept();
        tvm.resetStorage();
        _owner = owner;
        marketAddress = _marketAddress;
        userAccountManager = _userAccountManager;
        marketInfo = _marketInfo;
        tokenPrices = _tokenPrices;
        contractCodeVersion = _codeVersion;
    }
\end{lstlisting}
\paragraph{Some functions inherited by using}
